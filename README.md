# GPToWIN

Дипломная работа (Москва, 2024) про связку **Chrome-расширения** и **Windows-приложения**, которая позволяет управлять ChatGPT прямо из веб-интерфейса, но **использовать его как локальный API** для своих проектов.

Ключевая идея: ты продолжаешь работать в обычном UI ChatGPT (история, диалоги, контекст, привычный чат), а локальные приложения получают доступ к этому UI через локальный RPC-канал. На момент написания диплома это рассматривалось как уникальное решение именно в таком виде: “веб-клиент = API”, без официальных ключей и без потери привычного интерфейса.

Репозиторий состоит из двух почти независимых частей:

- **`chatgpt-chrome-ext/`** – Chrome-расширение: превращает вкладку ChatGPT в RPC-клиент и добавляет элементы управления (например, **Send** на код-блоках).
- **`src/WinTermPlus/`** – WPF-терминал для Windows: кастомный терминал-эмулятор с возможностью I/O через локальный API (SignalR hub на localhost). В этой сборке терминал также выступает “хостом” для расширения.

> Важно: расширение можно использовать и без терминала. Нужен только локальный SignalR-хаб с совместимым протоколом (его можно поднять отдельным мини-сервисом).

---

## Почему SignalR (а не “простой WebSocket”)

SignalR тут нужен не “потому что модно”, а потому что:

1) **Каждая вкладка = отдельный инстанс ChatGPT по контексту.**  
   Каждая вкладка ChatGPT устанавливает отдельное соединение с локальным хабом. Если у тебя открыты разные диалоги в разных вкладках, то это реально разные контексты, и они могут обрабатываться параллельно.

2) **Надёжность и удобство транспорта.**  
   Reconnect, состояние соединения, единый протокол и нормальный серверный API без самописной обвязки.

---

## Что это даёт

### 1) “Бесплатный локальный API” поверх веб-клиента ChatGPT
Расширение подключается к `http://localhost:<port>/chathub` и:
- принимает команды от локального хаба;
- вызывает методы управления ChatGPT на странице (через `chatgpt.js`);
- возвращает результаты обратно локальному коду.

Локальный проект может делать сценарии вида:
- “Отправь промпт”
- “Дождись окончания генерации”
- “Верни текст последнего ответа”
…и всё это происходит в настоящем чате, который ты видишь глазами и можешь контролировать вручную.

### 2) Терминал с локальным API (I/O)
WinTermPlus – не просто “окошко с ANSI”. Он умеет:
- принимать входящие команды/текст из локального API (от расширения или другого клиента),
- печатать/выполнять это в консоли,
- собирать “последний вывод” и отправлять наружу,
- реагировать на промпты/паттерны через регулярки.

---

## Состав проекта

### `chatgpt-chrome-ext` (расширение)

Функции:
- Подключение к локальному SignalR-хабу.
- RPC-вызовы/обработчики на базе `chatgpt.js` (в т.ч. сценарий “ask → wait → get reply”).
- Кнопка **Send** на код-блоках в чате (отправка кода наружу в локальное приложение).
- Режимы “авто” (зависят от настроек в `content.js`):
  - автоматическая отправка блока кода,
  - автоматическая вставка текста в поле ввода,
  - автоматический клик “Send”,
  - фильтрация по языкам кода (если включена).

Совместимость доменов:
- В `manifest.json` предусмотрены `https://chatgpt.com/*` и `https://chat.openai.com/*`. Если используешь другой домен/зеркало, правь `matches/host_permissions`.

### `WinTermPlus` (WPF терминал + хост хаба)

Функции:
- терминальная сессия через `winpty.NET`,
- рендеринг ANSI/буфер терминала,
- профили запуска (`config.json`),
- захват результата по детекту “промпта”,
- локальный SignalR-хаб на `localhost:<port>/chathub`.

---

## Быстрый старт

### Требования
- Windows 10/11
- .NET SDK (WPF/.NET)
- Chrome / Chromium

### 1) Запуск WinTermPlus (поднимает локальный hub)
Открой `WinTermPlus.sln` в Visual Studio и запусти `WinTermPlus`.

Либо через CLI:
```bash
dotnet restore
dotnet build src/WinTermPlus/WinTermPlus.csproj -c Release
dotnet run --project src/WinTermPlus/WinTermPlus.csproj
